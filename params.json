{"name":"tapl-study","tagline":"","body":"第X回 型システム入門勉強会\r\n==========================\r\n\r\n# 第5章 型無しラムダ計算 \r\n\r\n## おさらい\r\n\r\nQ1. ラムダ計算ってなんですか？\r\n\r\n関数とその適用規則のみで表現された数理体系のことです。\r\n文法は以下のとおり。\r\n\r\n    t ::=                     項:\r\n          x                 変数\r\n          \\x.t        ラムダ抽象\r\n          t t           関数適用\r\n    \r\n\r\nたった4行の短い文法ですが、あらゆる計算を表現可能です。\r\n\r\nQ2. どのへんが「形無し」なんですか？\r\n\r\nそもそも本書における「型」について学んでないので「型無し」と言われても・・・という感じではありますが、\r\n「項の定義において、右辺に再帰的に現れる項についていかなる制限も存在しないこと」\r\nと捉えてよいと思います。\r\n\r\n5.2「ラムダ計算でのプログラミング」ではChrch数の定義とその計算体系についてまとめられていました。\r\n\r\nこの体系は直感とは反する動きをする事があります。\r\nたとえば、Chrchブール値は真偽値を表し、Chrch数は整数値を表していました。\r\n\r\n    tru = \\t -> \\f -> t\r\n    c0 = \\s -> \\z -> z\r\n\r\nさらに、加算plusの定義は以下のとおり:\r\n\r\n    plus = \\m -> \\n -> \\s -> \\z -> m s (n s z)\r\n    \r\nこの定義において、plus tru c0という項は、ラムダ計算上は評価可能です。\r\n\r\n    plus tru c0 = ((\\m -> \\n -> \\s -> \\z -> m s (n s z)) tru) c0\r\n                = (\\n -> \\s -> \\z -> tru s (n s z)) c0\r\n                = \\s -> \\z -> tru s (c0 s z)\r\n                = \\s -> \\z -> c0 s z\r\n                = \\s -> \\z -> z\r\n\r\n最終的にc0と等価なラムダ抽象へと簡約されていますが、これは明らかに直感に反しています。\r\nそもそも真偽値と整数値を加算できること自体が、起きてはならない事象なのですから。\r\nこれは関数に型が無いゆえに起きる問題です。\r\n\r\n----\r\n\r\nと書いたところで、p.43の値呼び戦略の評価の完了を見ていてふと疑問が・・・\r\n\r\n    id (id (\\z -> id z)) = id (\\z -> id z)\r\n                         = \\z -> id z (完了)\r\n\r\nなんでid zはzへと簡約されないのでしょうか？\r\n\r\n - zが閉じた項ではないから\r\n - 抽象内部での簡約を許さないから\r\n\r\nこれをふまえると、簡約基(tru s (c1 s z)をc0 s zへと監訳していいものか甚だ疑問ですが、\r\nするとplus c0 c1のような妥当な式もc2へ簡約できません。\r\n\r\n何が間違っているのでしょうか？\r\n\r\n## 5.3 形式的議論\r\n\r\nまずラムダ計算の構文を形式的に定義する。\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}