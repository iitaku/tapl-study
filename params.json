{"name":"tapl-study","tagline":"","body":"第X回 型システム入門勉強会\r\n==========================\r\n\r\n# 第5章 型無しラムダ計算 \r\n\r\n## おさらい\r\n\r\nQ1. ラムダ計算ってなんですか？\r\n\r\n関数とその適用規則のみで表現された数理体系のことです。\r\n文法は以下のとおり。\r\n\r\n>     t ::=                     項:\r\n>           x                 変数\r\n>           λx.t        ラムダ抽象\r\n>           t t           関数適用\r\n\r\nたった4行の短い文法ですが、あらゆる計算を表現可能です。\r\n\r\nQ2. どのへんが「形無し」なんですか？\r\n\r\nそもそも本書における「型」について学んでないので「型無し」と言われても・・・という感じではありますが、\r\n「項の定義において、右辺に再帰的に現れる項についていかなる制限も存在しないこと」\r\nと捉えてよいと思います。\r\n\r\n5.2「ラムダ計算でのプログラミング」ではChrch数の定義とその計算体系についてまとめられていました。\r\n\r\nこの体系は直感とは反する動きをする事があります。\r\nたとえば、Chrchブール値は真偽値を表し、Chrch数は整数値を表していました。\r\n\r\n>     tru = λt. λf. t;\r\n>     c0 = λs. λz. z;\r\n\r\nさらに、加算plusの定義は以下のとおり:\r\n\r\n>     plus= λm. λn. λs. λz. m s (n s z);\r\n    \r\nこの定義において、plus tru c0という項は、ラムダ計算上は評価可能です。\r\n\r\n    plus tru c0 = ((λm. λn. λs. λz. m s (n s z)) tru) c0\r\n                = (λn. λs. λz. tru s (n s z)) c0\r\n                = λs. λz. tru s (c0 s z)\r\n                = λs. λz. c0 s z\r\n                = λs. λz. z\r\n\r\n最終的にc0と等価なラムダ抽象へと簡約されていますが、これは明らかに直感に反しています。\r\nそもそも真偽値と整数値を加算できること自体が、起きてはならない事象なのですから。\r\nこれはラムダ抽象に型が無いゆえに起きる問題です。\r\n\r\n----\r\n\r\nと書いたところで、p.43の値呼び戦略の評価の完了を見ていてふと疑問が・・・\r\n\r\n>        id (id (λz. id z))\r\n>      = id (λz. id z)\r\n>      = λz. id z\r\n>      // 簡約完了\r\n\r\nなんでλz. id zはλz . zへと簡約されないのでしょうか？\r\n\r\n - zが閉じた項ではないから？\r\n - 抽象内部での簡約を許さないから？\r\n\r\nこれをふまえると、簡約基(tru s (c1 s z)をc0 s zへと監訳していいものか甚だ疑問ですが、\r\nするとplus c0 c1のような妥当な項もc2へ簡約できません。\r\n\r\n何が間違っているのでしょうか？\r\n\r\n----\r\n\r\n更に追記：\r\n\r\nこれは、いわゆる振る舞い等価では？\r\n\r\n## 5.3 形式的議論\r\n\r\n### 構文\r\n\r\nまずラムダ計算の構文を形式的に定義します。\r\n\r\n> 定義 5.3.1.[項] V を変数名の可算集合とする。項の集合は以下を満たす最小の集合 T である。\r\n> (1) 任意のx∈ V についてx∈ T\r\n> (2) t1 ∈T かつx∈V ならば、λx.t1 ∈T\r\n> (3) t1 ∈T かつt2 ∈T ならば、t1t2 ∈T\r\n\r\nここで、**項のサイズ**について考えます。\r\n定義 3.3.2.と同様に定義できるらしい。\r\n\r\n> 定義 3.3.2. 項 t のサイズを size(t) と書き、次のように定義する。\r\n\r\n>     size(true)               = 1\r\n>     size(false)              = 1\r\n>     size(0)                  = 1\r\n>     size(succ t1)            = size(t1) + 1\r\n>     size(pred t1)            = size(t1) + 1\r\n>     size(iszero t1)          = size(t1) + 1\r\n>     size(ift1 thent2 elset3) = size(t1) + size(t2) + size(t3) + 1\r\n\r\nつまり、tのサイズはtの抽象構文木のノードの数となります。\r\n\r\n    size(x)      = 1\r\n    size(λx. t1) = size(t1) + 1\r\n    size(t1 t2)  = size(t1) + size(t2)\r\n\r\nさらに、項に現れる自由変数の集合も再帰的に定義ができます。\r\n\r\n> 定義5.3.2. 項tの自由変数(freevariable)の集合は、FV(t)と書かれ、以下のように定義できる。\r\n\r\n>     FV(x)      = {x}\r\n>     FV(λx. t1) = FV(t1) \\ {x}\r\n>     FV(t1 t2)  = FV(t1)∪FV(t2)\r\n\r\n変数xという項の自由変数の集合は、xただ1つからなる集合である、という1つ目の定義が再帰的定義の基底です。\r\n残りはラムダ計算の文法の再帰的定義に合わせて、\r\n\r\n - ラムダ抽象の引数は束縛変数（自由でない）ので抽象本体の自由変数の集合と{x}の差集合\r\n - 関数適用はt1とt2の2つの項の自由変数の集合の和集合\r\n\r\nという感じ。\r\n\r\n> 演習5.3.3. 任意の項tについて|FV(t)| ≤ size(t)が成り立つことを注意深く証明せよ。\r\n\r\ntのサイズについて再帰的に証明します。\r\nつまり、tより小さなサイズの項t1およびt2について、\r\n`|FV(t1)| ≤ size(t1)`が成り立つと仮定し(t2も同様)、\r\ntについても同様に成り立つことを示す。\r\n\r\nラムダ計算の定義の3つの右辺それぞれについて考える。\r\n\r\n(1) t = xの場合\r\nこれは明らかに成り立つ。\r\n\r\n    |FV(x)| = |{x}| = 1 = size(x)\r\n\r\n(2) t = λx. t1の場合\r\n\r\n    |FV(λx. t1)| = |FV(t1) \\ {x}|\r\n\r\nここで、`|FV(t1)| ≤ size(t1)`という仮定より、`|FV(t1) \\ {x}| ≤ size(t1)`である。\r\nつまり、`|FV(t)| ≤ |FV(t1)|`は常に成り立つ。\r\n仮定より`|FV(t)| ≤ |FV(t1)| ≤ size(t1) ≤ size(t)`が成り立つ。\r\n\r\n(3) t = t1 t2の場合\r\n\r\n    |FV(t1 t2)| = |FV(t1)∪FV(t2)|\r\n\r\nであり、仮定より`|FV(t1)∪FV(t2)| ≤ size(t1) + size(t2)`となる。\r\n定義より、`size(t1) + size(t2) = size(t1 t2)`であるから、\r\n`|FV(t1 t2)| ≤ size(t1 t2)`が成り立つ。\r\n\r\n### 代入\r\n\r\n代入の操作について、形式的に定義することを試みる。\r\n\r\nまず最も素朴な定義から出発する。\r\n\r\n>     [x |-> s] x        = s\r\n>     [x |-> s] y        = y   (y != xの場合)\r\n>     [x |-> s] (λy. t1) = λy. [x |-> s] t1\r\n>     [x |-> s] (t1 t2)  = ([x |-> s] t1) ([x |-> s] t2) \r\n\r\n一見正しそうに見えるが、この代入はどうなるか？\r\n\r\n    [x |-> y] (λx. x)\r\n\r\n3つ目の定義より、抽象本体のxをyで置き換えて、こうなる。\r\n\r\n    [x |-> y] (λx. x) = λx. y\r\n\r\nこれは、関数抽象において、束縛変数の名前を問わないという直感に反する。\r\nたとえば次の代入の左辺は明らかに上の定義と等価だが、右辺は異なる。\r\n\r\n    [x |-> y] (λz. z) = λz. z\r\n\r\nここでの問題は、自由変数と束縛変数を区別しなかったことにある。\r\n\r\n> 代入のこの素朴な定義で犯した最初の誤りは、明らかに、変数 x の項 t 内での自由な出現と、束 縛された出現を区別しなかったことである。\r\n\r\nつまり、置き換えの対象となる項の中に、変換規則の左辺と同じ名前の束縛変数があったら、そこで簡約を中止しなければならない。 この場合は以下の様な定義で表される。\r\n\r\n>     [x |-> s] x        = s\r\n>     [x |-> s] y        = y                (y != xの場合)\r\n>     [x |-> s] (λy. t1) = λy. t1           (y == xの場合)\r\n>     [x |-> s] (λy. t1) = λy. [x |-> s] t1 (y != xの場合)\r\n>     [x |-> s] (t1 t2)  = ([x |-> s] t1) ([x |-> s] t2) \r\n\r\n3行目がふえた。\r\nしかし、これでも不完全である。\r\n\r\n>     [x |-> z] (λz. x) = λz. z\r\n\r\n今度は先ほどの例とは逆に、逆に束縛変数と競合してしまった。\r\nそこで、制限を追加する。\r\n\r\n>     [x |-> s] x        = s\r\n>     [x |-> s] y        = y                (x != yの場合)\r\n>     [x |-> s] (λy. t1) = λy. t1           (x == yの場合)\r\n>     [x |-> s] (λy. t1) = λy. [x |-> s] t1 (y != xかつFV(s)がyを含まない場合)\r\n>     [x |-> s] (t1 t2)  = ([x |-> s] t1) ([x |-> s] t2) \r\n\r\nこれで、少なくとも代入がおこなわれる時には、正しく動く。\r\nしかし、制限を加えた結果、代入はもはや全域的な操作ではなくなった。\r\n例えば、\r\n\r\n    [x |-> y z] (λy. x y) \r\n\r\nは、どのような結果も与えない。代入のどのルールも当てはまらないからである。\r\nこの問題に対する修正として、以下の様な慣習を取り入れる。\r\n\r\n慣習 5.3.4. 束縛変数の名前のみが異なる項は、任意の文脈で置き換え可能である。\r\n\r\n例えば、`[x |-> y z] (λy. x y)`を計算したいときには、\r\n最初に`(λy. x y)`を例えば`(λw. x w)`へと書き換える。\r\nその後、`[x |-> y z](λw. x w)` を計算し、`(λw. y z w)` を得る。\r\n\r\n代入操作が未定義になるようなときには、常にこの慣習を適用することで、完全な代入の定義が得られる。\r\n\r\n>     [x |-> s] x        = s\r\n>     [x |-> s] y        = y                (x != yの場合)\r\n>     [x |-> s] (λy. t1) = λy. [x |-> s] t1 (y != xかつFV(s)がyを含まない場合)\r\n>     [x |-> s] (t1 t2)  = ([x |-> s] t1) ([x |-> s] t2) \r\n\r\n`y==x`となる時や、 `FV(s)`がyを含むようなときには、抽象本体の束縛変数yを任意の変数名に置き換えればよい。\r\n以上で、全域的な、破綻のない代入の形式的定義が得られた。\r\n\r\n### 操作的意味論\r\n\r\nまとめとして、操作的意味論の要約を示す。\r\n\r\n構文:\r\n>     t ::=                     項:\r\n>           x                 変数\r\n>           λx.t        ラムダ抽象\r\n>           t t           関数適用\r\n>\r\n>     v ::=                     値:\r\n>           λx.t        ラムダ抽象\r\n\r\n評価:\r\n>        t1 -> t1'\r\n>     ---------------      (E-APP1)\r\n>     t1 t2 -> t1' t2\r\n>   \r\n>        t2 -> t2'\r\n>     ---------------      (E-APP2)\r\n>     v1 t2 -> v1 t2'\r\n>   \r\n>     (λx. t12) v2 -> [x |-> v2] t12  (E-APPABS)\r\n>   \r\n\r\nE-APPABSは計算規則であり、ラムダ計算唯一の簡約、関数適用を表す。\r\nD-APP1とE-APP2は3章でもやったように、評価戦略を決定する合同規則である。\r\n\r\nvは値、つまりラムダ抽象の上を動くことに注意すると、\r\nこれを規則に含むE-APP2とE-APPABSは、その項がラムダ抽象に簡約されるまで適用できない。\r\nつまり、\r\n\r\n1. E-APP1によって関数適用の左側を評価する\r\n2. E-APP2によって関数適用の右側を評価する\r\n3. 最後にE-APPABSによって関数適用という評価を行\r\n\r\nこれは、値呼び評価戦略である。\r\n\r\n> 演習5.3.6. これらの規則を変更し、他の三種の評価戦略(完全ベータ簡約、正規順序、遅延評価)を表現するようにせよ。\r\n\r\n完全ベータ簡約は非決定である。\r\n簡約順序に基底がなく、全ての簡約基はいかなるタイミングでも簡約可能だからである。\r\n\r\n完全ベータ簡約の評価:\r\n>         t1 -> t1'\r\n>      ---------------      (E-APP1)\r\n>      t1 t2 -> t1' t2\r\n>   \r\n>         t2 -> t2'\r\n>      ---------------      (E-APP2)\r\n>      v1 t2 -> v1 t2'\r\n>\r\n>         t1 -> t1'\r\n>     -----------------     (E-ABS)\r\n>     λx. t1 -> λx. t1'\r\n>   \r\n>     (λx. t12) v2 -> [x |-> v2] t12  (E-APPABS)\r\n>   \r\n\r\n正規順序簡約の場合、外側の簡約基から評価しなければならない。\r\n評価規則を正しく書き下すため、項を以下のように分類する。\r\n\r\n\r\n>     nf ::=            正規形         \r\n>            λx. nf              \r\n>            nanf\r\n>\r\n>     nanf ::=          非抽象正規形           \r\n>              x\r\n>              nanf nf\r\n>     na ::=            非抽象\r\n>            x\r\n>            t1 t2\r\n\r\n\r\n正規順序簡約は、完全ベータ簡約に評価の順序を与えたものである。\r\n\r\n>           na -> t1'\r\n>        ---------------      (E-APP1)\r\n>        na t2 -> t1' t2\r\n>   \r\n>           t2 -> t2'\r\n>     ---------------------   (E-APP2)\r\n>     nanf1 t2 -> nanf1 t2'\r\n>\r\n>           t1 -> t1'\r\n>        ---------------      (E-ABS)\r\n>        λx. t1 -> λx. t1'\r\n>\r\n>        (λx. t12) v2 -> [x |-> v2] t12  (E-APPABS)\r\n>   \r\n\r\n遅延評価の規則は簡単である。抽象内部は評価されないので、規則E-APP2が削られている。\r\n\r\n>        t1 -> t1'\r\n>     ---------------      (E-APP1)\r\n>     t1 t2 -> t1' t2\r\n>   \r\n>     (λx. t12) v2 -> [x |-> v2] t12  (E-APPABS)\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}