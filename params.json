{"name":"tapl-study","tagline":"","body":"第X回 型システム入門勉強会\r\n==========================\r\n\r\n# 第5章 型無しラムダ計算 \r\n\r\n## おさらい\r\n\r\nQ1. ラムダ計算ってなんですか？\r\n\r\n関数とその適用規則のみで表現された数理体系のことです。\r\n文法は以下のとおり。\r\n\r\n>     t ::=                     項:\r\n>           x                 変数\r\n>           λx.t        ラムダ抽象\r\n>           t t           関数適用\r\n\r\nたった4行の短い文法ですが、あらゆる計算を表現可能です。\r\n\r\nQ2. どのへんが「形無し」なんですか？\r\n\r\nそもそも本書における「型」について学んでないので「型無し」と言われても・・・という感じではありますが、\r\n「項の定義において、右辺に再帰的に現れる項についていかなる制限も存在しないこと」\r\nと捉えてよいと思います。\r\n\r\n5.2「ラムダ計算でのプログラミング」ではChrch数の定義とその計算体系についてまとめられていました。\r\n\r\nこの体系は直感とは反する動きをする事があります。\r\nたとえば、Chrchブール値は真偽値を表し、Chrch数は整数値を表していました。\r\n\r\n>     tru = λt. λf. t;\r\n>     c0 = λs. λz. z;\r\n\r\nさらに、加算plusの定義は以下のとおり:\r\n\r\n>     plus= λm. λn. λs. λz. m s (n s z);\r\n    \r\nこの定義において、plus tru c0という項は、ラムダ計算上は評価可能です。\r\n\r\n    plus tru c0 = ((λm. λn. λs. λz. m s (n s z)) tru) c0\r\n                = (λn. λs. λz. tru s (n s z)) c0\r\n                = λs. λz. tru s (c0 s z)\r\n                = λs. λz. c0 s z\r\n                = λs. λz. z\r\n\r\n最終的にc0と等価なラムダ抽象へと簡約されていますが、これは明らかに直感に反しています。\r\nそもそも真偽値と整数値を加算できること自体が、起きてはならない事象なのですから。\r\nこれはラムダ抽象に型が無いゆえに起きる問題です。\r\n\r\n----\r\n\r\nと書いたところで、p.43の値呼び戦略の評価の完了を見ていてふと疑問が・・・\r\n\r\n>        id (id (λz. id z))\r\n>      = id (λz. id z)\r\n>      = λz. id z\r\n>      // 簡約完了\r\n\r\nなんでλz. id zはλz . zへと簡約されないのでしょうか？\r\n\r\n - zが閉じた項ではないから？\r\n - 抽象内部での簡約を許さないから？\r\n\r\nこれをふまえると、簡約基(tru s (c1 s z)をc0 s zへと監訳していいものか甚だ疑問ですが、\r\nするとplus c0 c1のような妥当な項もc2へ簡約できません。\r\n\r\n何が間違っているのでしょうか？\r\n\r\n## 5.3 形式的議論\r\n\r\nまずラムダ計算の構文を形式的に定義します。\r\n\r\n> 定義 5.3.1.[項] V を変数名の可算集合とする。項の集合は以下を満たす最小の集合 T である。\r\n> (1) 任意のx∈ V についてx∈ T\r\n> (2) t1 ∈T かつx∈V ならば、λx.t1 ∈T\r\n> (3) t1 ∈T かつt2 ∈T ならば、t1t2 ∈T\r\n\r\nここで、**項のサイズ**について考えます。\r\n定義 3.3.2.と同様に定義できるらしい。\r\n\r\n> 定義 3.3.2. 項 t のサイズを size(t) と書き、次のように定義する。\r\n\r\n>     size(true)               = 1\r\n>     size(false)              = 1\r\n>     size(0)                  = 1\r\n>     size(succ t1)            = size(t1) + 1\r\n>     size(pred t1)            = size(t1) + 1\r\n>     size(iszero t1)          = size(t1) + 1\r\n>     size(ift1 thent2 elset3) = size(t1) + size(t2) + size(t3) + 1\r\n\r\nつまり、tのサイズはtの抽象構文木のノードの数となります。\r\n\r\n    size(x)      = 1\r\n    size(λx. t1) = size(t1) + 1\r\n    size(t1 t2)  = size(t1) + size(t2)\r\n\r\nさらに、項に現れる自由変数の集合も再帰的に定義ができます。\r\n\r\n> 定義5.3.2. 項tの自由変数(freevariable)の集合は、FV(t)と書かれ、以下のように定義できる。\r\n\r\n>     FV(x)      = {x}\r\n>     FV(λx. t1) = FV(t1) \\ {x}\r\n>     FV(t1 t2)  = FV(t1)∪FV(t2)\r\n\r\n変数xという項の自由変数の集合は、xただ1つからなる集合である、という1つ目の定義が再帰的定義の基底です。\r\n残りはラムダ計算の文法の再帰的定義に合わせて、\r\n\r\n - ラムダ抽象の引数は束縛変数（自由でない）ので抽象本体の自由変数の集合と{x}の差集合\r\n - 関数適用はt1とt2の2つの項の自由変数の集合の和集合\r\n\r\nという感じ。\r\n\r\n> 演習5.3.3. 任意の項tについて|FV(t)| ≤ size(t)が成り立つことを注意深く証明せよ。\r\n\r\ntのサイズについて再帰的に証明します。\r\nつまり、tより小さなサイズの項t1およびt2について、\r\n|FV(t1)| ≤ size(t1)が成り立つと仮定し(t2も同様)、\r\ntについても同様に成り立つことを示す。\r\n\r\nラムダ計算の定義の3つの右辺それぞれについて考える。\r\n\r\n(1) t = xの場合\r\nこれは明らかに成り立つ。\r\n\r\n    |FV(x)| = |{x}| = 1 = size(x)\r\n\r\n(2) t = λx. t1の場合\r\n\r\n    |FV(λx. t1)| = |FV(t1) \\ {x}|\r\n\r\nここで、|FV(t1)| ≤ size(t1)という仮定より、|FV(t1) \\ {x}| ≤ size(t1)である。\r\nつまり、|FV(t)| ≤ |FV(t1)|は常に成り立つ。\r\n仮定より|FV(t)| ≤ |FV(t1)| ≤ size(t1) ≤ size(t)が成り立つ。\r\n\r\n(3) t = t1 t2の場合\r\n\r\n    |FV(t1 t2)| = |FV(t1)∪FV(t2)|\r\n\r\nであり、仮定より|FV(t1)∪FV(t2)| ≤ size(t1) + size(t2)となる。\r\n定義より、size(t1) + size(t2) = size(t1 t2)であるから、\r\n|FV(t1 t2)| ≤ size(t1 t2)が成り立つ。\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}