<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <title>tapl-study by iitaku</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>tapl-study</h1>
        <h2></h2>

        <section id="downloads">
          <a href="https://github.com/iitaku/tapl-study/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/iitaku/tapl-study/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/iitaku/tapl-study" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1>
<a name="x-" class="anchor" href="#x-"><span class="octicon octicon-link"></span></a>第X回 型システム入門勉強会</h1>

<h1>
<a name="5-" class="anchor" href="#5-"><span class="octicon octicon-link"></span></a>第5章 型無しラムダ計算</h1>

<h2>
<a name="" class="anchor" href="#"><span class="octicon octicon-link"></span></a>おさらい</h2>

<p>Q1. ラムダ計算ってなんですか？</p>

<p>関数とその適用規則のみで表現された数理体系のことです。
文法は以下のとおり。</p>

<blockquote>
<pre><code>t ::=                     項:
      x                 変数
      λx.t        ラムダ抽象
      t t           関数適用
</code></pre>
</blockquote>

<p>たった4行の短い文法ですが、あらゆる計算を表現可能です。</p>

<p>Q2. どのへんが「形無し」なんですか？</p>

<p>そもそも本書における「型」について学んでないので「型無し」と言われても・・・という感じではありますが、
「項の定義において、右辺に再帰的に現れる項についていかなる制限も存在しないこと」
と捉えてよいと思います。</p>

<p>5.2「ラムダ計算でのプログラミング」ではChrch数の定義とその計算体系についてまとめられていました。</p>

<p>この体系は直感とは反する動きをする事があります。
たとえば、Chrchブール値は真偽値を表し、Chrch数は整数値を表していました。</p>

<blockquote>
<pre><code>tru = λt. λf. t;
c0 = λs. λz. z;
</code></pre>
</blockquote>

<p>さらに、加算plusの定義は以下のとおり:</p>

<blockquote>
<pre><code>plus= λm. λn. λs. λz. m s (n s z);
</code></pre>
</blockquote>

<p>この定義において、plus tru c0という項は、ラムダ計算上は評価可能です。</p>

<pre><code>plus tru c0 = ((λm. λn. λs. λz. m s (n s z)) tru) c0
            = (λn. λs. λz. tru s (n s z)) c0
            = λs. λz. tru s (c0 s z)
            = λs. λz. c0 s z
            = λs. λz. z
</code></pre>

<p>最終的にc0と等価なラムダ抽象へと簡約されていますが、これは明らかに直感に反しています。
そもそも真偽値と整数値を加算できること自体が、起きてはならない事象なのですから。
これはラムダ抽象に型が無いゆえに起きる問題です。</p>

<hr><p>と書いたところで、p.43の値呼び戦略の評価の完了を見ていてふと疑問が・・・</p>

<blockquote>
<pre><code>   id (id (λz. id z))
 = id (λz. id z)
 = λz. id z
 // 簡約完了
</code></pre>
</blockquote>

<p>なんでλz. id zはλz . zへと簡約されないのでしょうか？</p>

<ul>
<li>zが閉じた項ではないから？</li>
<li>抽象内部での簡約を許さないから？</li>
</ul><p>これをふまえると、簡約基(tru s (c1 s z)をc0 s zへと監訳していいものか甚だ疑問ですが、
するとplus c0 c1のような妥当な項もc2へ簡約できません。</p>

<p>何が間違っているのでしょうか？</p>

<h2>
<a name="53-" class="anchor" href="#53-"><span class="octicon octicon-link"></span></a>5.3 形式的議論</h2>

<p>まずラムダ計算の構文を形式的に定義します。</p>

<blockquote>
<p>定義 5.3.1.[項] V を変数名の可算集合とする。項の集合は以下を満たす最小の集合 T である。
(1) 任意のx∈ V についてx∈ T
(2) t1 ∈T かつx∈V ならば、λx.t1 ∈T
(3) t1 ∈T かつt2 ∈T ならば、t1t2 ∈T</p>
</blockquote>

<p>ここで、**項のサイズ**について考えます。
定義 3.3.2.と同様に定義できるらしい。</p>

<blockquote>
<p>定義 3.3.2. 項 t のサイズを size(t) と書き、次のように定義する。</p>

<pre><code>size(true)               = 1
size(false)              = 1
size(0)                  = 1
size(succ t1)            = size(t1) + 1
size(pred t1)            = size(t1) + 1
size(iszero t1)          = size(t1) + 1
size(ift1 thent2 elset3) = size(t1) + size(t2) + size(t3) + 1
</code></pre>
</blockquote>

<p>つまり、tのサイズはtの抽象構文木のノードの数となります。</p>

<pre><code>size(x)      = 1
size(λx. t1) = size(t1) + 1
size(t1 t2)  = size(t1) + size(t2)
</code></pre>

<p>さらに、項に現れる自由変数の集合も再帰的に定義ができます。</p>

<blockquote>
<p>定義5.3.2. 項tの自由変数(freevariable)の集合は、FV(t)と書かれ、以下のように定義できる。</p>

<pre><code>FV(x)      = {x}
FV(λx. t1) = FV(t1) \ {x}
FV(t1 t2)  = FV(t1)∪FV(t2)
</code></pre>
</blockquote>

<p>変数xという項の自由変数の集合は、xただ1つからなる集合である、という1つ目の定義が再帰的定義の基底です。
残りはラムダ計算の文法の再帰的定義に合わせて、</p>

<ul>
<li>ラムダ抽象の引数は束縛変数（自由でない）ので抽象本体の自由変数の集合と{x}の差集合</li>
<li>関数適用はt1とt2の2つの項の自由変数の集合の和集合</li>
</ul><p>という感じ。</p>

<blockquote>
<p>演習5.3.3. 任意の項tについて|FV(t)| ≤ size(t)が成り立つことを注意深く証明せよ。</p>
</blockquote>

<p>tのサイズについて再帰的に証明します。
つまり、tより小さなサイズの項t1およびt2について、
|FV(t1)| ≤ size(t1)が成り立つと仮定し(t2も同様)、
tについても同様に成り立つことを示す。</p>

<p>ラムダ計算の定義の3つの右辺それぞれについて考える。</p>

<p>(1) t = xの場合
これは明らかに成り立つ。</p>

<pre><code>|FV(x)| = |{x}| = 1 = size(x)
</code></pre>

<p>(2) t = λx. t1の場合</p>

<pre><code>|FV(λx. t1)| = |FV(t1) \ {x}|
</code></pre>

<p>ここで、|FV(t1)| ≤ size(t1)という仮定より、|FV(t1) \ {x}| ≤ size(t1)である。
つまり、|FV(t)| ≤ |FV(t1)|は常に成り立つ。
仮定より|FV(t)| ≤ |FV(t1)| ≤ size(t1) ≤ size(t)が成り立つ。</p>

<p>(3) t = t1 t2の場合</p>

<pre><code>|FV(t1 t2)| = |FV(t1)∪FV(t2)|
</code></pre>

<p>であり、仮定より|FV(t1)∪FV(t2)| ≤ size(t1) + size(t2)となる。
定義より、size(t1) + size(t2) = size(t1 t2)であるから、
|FV(t1 t2)| ≤ size(t1 t2)が成り立つ。</p>
      </section>
    </div>

    
  </body>
</html>