<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <title>tapl-study by iitaku</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>tapl-study</h1>
        <h2></h2>

        <section id="downloads">
          <a href="https://github.com/iitaku/tapl-study/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/iitaku/tapl-study/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/iitaku/tapl-study" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1>
<a name="x-" class="anchor" href="#x-"><span class="octicon octicon-link"></span></a>第X回 型システム入門勉強会</h1>

<h1>
<a name="5-" class="anchor" href="#5-"><span class="octicon octicon-link"></span></a>第5章 型無しラムダ計算</h1>

<h2>
<a name="" class="anchor" href="#"><span class="octicon octicon-link"></span></a>おさらい</h2>

<p>Q1. ラムダ計算ってなんですか？</p>

<p>関数とその適用規則のみで表現された数理体系のことです。
文法は以下のとおり。</p>

<blockquote>
<pre><code>t ::=                     項:
      x                 変数
      λx.t        ラムダ抽象
      t t           関数適用
</code></pre>
</blockquote>

<p>たった4行の短い文法ですが、あらゆる計算を表現可能です。</p>

<p>Q2. どのへんが「形無し」なんですか？</p>

<p>そもそも本書における「型」について学んでないので「型無し」と言われても・・・という感じではありますが、
「項の定義において、右辺に再帰的に現れる項についていかなる制限も存在しないこと」
と捉えてよいと思います。</p>

<p>5.2「ラムダ計算でのプログラミング」ではChrch数の定義とその計算体系についてまとめられていました。</p>

<p>この体系は直感とは反する動きをする事があります。
たとえば、Chrchブール値は真偽値を表し、Chrch数は整数値を表していました。</p>

<blockquote>
<pre><code>tru = λt. λf. t;
c0 = λs. λz. z;
</code></pre>
</blockquote>

<p>さらに、加算plusの定義は以下のとおり:</p>

<blockquote>
<pre><code>plus= λm. λn. λs. λz. m s (n s z);
</code></pre>
</blockquote>

<p>この定義において、plus tru c0という項は、ラムダ計算上は評価可能です。</p>

<pre><code>plus tru c0 = ((λm. λn. λs. λz. m s (n s z)) tru) c0
            = (λn. λs. λz. tru s (n s z)) c0
            = λs. λz. tru s (c0 s z)
            = λs. λz. c0 s z
            = λs. λz. z
</code></pre>

<p>最終的にc0と等価なラムダ抽象へと簡約されていますが、これは明らかに直感に反しています。
そもそも真偽値と整数値を加算できること自体が、起きてはならない事象なのですから。
これはラムダ抽象に型が無いゆえに起きる問題です。</p>

<hr><p>と書いたところで、p.43の値呼び戦略の評価の完了を見ていてふと疑問が・・・</p>

<blockquote>
<pre><code>   id (id (λz. id z))
 = id (λz. id z)
 = λz. id z
 // 簡約完了
</code></pre>
</blockquote>

<p>なんでλz. id zはλz . zへと簡約されないのでしょうか？</p>

<ul>
<li>zが閉じた項ではないから？</li>
<li>抽象内部での簡約を許さないから？</li>
</ul><p>これをふまえると、簡約基(tru s (c1 s z)をc0 s zへと監訳していいものか甚だ疑問ですが、
するとplus c0 c1のような妥当な項もc2へ簡約できません。</p>

<p>何が間違っているのでしょうか？</p>

<hr><p>更に追記：</p>

<p>これは、いわゆる振る舞い等価では？</p>

<h2>
<a name="53-" class="anchor" href="#53-"><span class="octicon octicon-link"></span></a>5.3 形式的議論</h2>

<h3>
<a name="-1" class="anchor" href="#-1"><span class="octicon octicon-link"></span></a>構文</h3>

<p>まずラムダ計算の構文を形式的に定義します。</p>

<blockquote>
<p>定義 5.3.1.[項] V を変数名の可算集合とする。項の集合は以下を満たす最小の集合 T である。
(1) 任意のx∈ V についてx∈ T
(2) t1 ∈T かつx∈V ならば、λx.t1 ∈T
(3) t1 ∈T かつt2 ∈T ならば、t1t2 ∈T</p>
</blockquote>

<p>ここで、**項のサイズ**について考えます。
定義 3.3.2.と同様に定義できるらしい。</p>

<blockquote>
<p>定義 3.3.2. 項 t のサイズを size(t) と書き、次のように定義する。</p>

<pre><code>size(true)               = 1
size(false)              = 1
size(0)                  = 1
size(succ t1)            = size(t1) + 1
size(pred t1)            = size(t1) + 1
size(iszero t1)          = size(t1) + 1
size(ift1 thent2 elset3) = size(t1) + size(t2) + size(t3) + 1
</code></pre>
</blockquote>

<p>つまり、tのサイズはtの抽象構文木のノードの数となります。</p>

<pre><code>size(x)      = 1
size(λx. t1) = size(t1) + 1
size(t1 t2)  = size(t1) + size(t2)
</code></pre>

<p>さらに、項に現れる自由変数の集合も再帰的に定義ができます。</p>

<blockquote>
<p>定義5.3.2. 項tの自由変数(freevariable)の集合は、FV(t)と書かれ、以下のように定義できる。</p>

<pre><code>FV(x)      = {x}
FV(λx. t1) = FV(t1) \ {x}
FV(t1 t2)  = FV(t1)∪FV(t2)
</code></pre>
</blockquote>

<p>変数xという項の自由変数の集合は、xただ1つからなる集合である、という1つ目の定義が再帰的定義の基底です。
残りはラムダ計算の文法の再帰的定義に合わせて、</p>

<ul>
<li>ラムダ抽象の引数は束縛変数（自由でない）ので抽象本体の自由変数の集合と{x}の差集合</li>
<li>関数適用はt1とt2の2つの項の自由変数の集合の和集合</li>
</ul><p>という感じ。</p>

<blockquote>
<p>演習5.3.3. 任意の項tについて|FV(t)| ≤ size(t)が成り立つことを注意深く証明せよ。</p>
</blockquote>

<p>tのサイズについて再帰的に証明します。
つまり、tより小さなサイズの項t1およびt2について、
<code>|FV(t1)| ≤ size(t1)</code>が成り立つと仮定し(t2も同様)、
tについても同様に成り立つことを示す。</p>

<p>ラムダ計算の定義の3つの右辺それぞれについて考える。</p>

<p>(1) t = xの場合
これは明らかに成り立つ。</p>

<pre><code>|FV(x)| = |{x}| = 1 = size(x)
</code></pre>

<p>(2) t = λx. t1の場合</p>

<pre><code>|FV(λx. t1)| = |FV(t1) \ {x}|
</code></pre>

<p>ここで、<code>|FV(t1)| ≤ size(t1)</code>という仮定より、<code>|FV(t1) \ {x}| ≤ size(t1)</code>である。
つまり、<code>|FV(t)| ≤ |FV(t1)|</code>は常に成り立つ。
仮定より<code>|FV(t)| ≤ |FV(t1)| ≤ size(t1) ≤ size(t)</code>が成り立つ。</p>

<p>(3) t = t1 t2の場合</p>

<pre><code>|FV(t1 t2)| = |FV(t1)∪FV(t2)|
</code></pre>

<p>であり、仮定より<code>|FV(t1)∪FV(t2)| ≤ size(t1) + size(t2)</code>となる。
定義より、<code>size(t1) + size(t2) = size(t1 t2)</code>であるから、
<code>|FV(t1 t2)| ≤ size(t1 t2)</code>が成り立つ。</p>

<h3>
<a name="-2" class="anchor" href="#-2"><span class="octicon octicon-link"></span></a>代入</h3>

<p>代入の操作について、形式的に定義することを試みる。</p>

<p>まず最も素朴な定義から出発する。</p>

<blockquote>
<pre><code>[x |-&gt; s] x        = s
[x |-&gt; s] y        = y   (y != xの場合)
[x |-&gt; s] (λy. t1) = λy. [x |-&gt; s] t1
[x |-&gt; s] (t1 t2)  = ([x |-&gt; s] t1) ([x |-&gt; s] t2) 
</code></pre>
</blockquote>

<p>一見正しそうに見えるが、この代入はどうなるか？</p>

<pre><code>[x |-&gt; y] (λx. x)
</code></pre>

<p>3つ目の定義より、抽象本体のxをyで置き換えて、こうなる。</p>

<pre><code>[x |-&gt; y] (λx. x) = λx. y
</code></pre>

<p>これは、関数抽象において、束縛変数の名前を問わないという直感に反する。
たとえば次の代入の左辺は明らかに上の定義と等価だが、右辺は異なる。</p>

<pre><code>[x |-&gt; y] (λz. z) = λz. z
</code></pre>

<p>ここでの問題は、自由変数と束縛変数を区別しなかったことにある。</p>

<blockquote>
<p>代入のこの素朴な定義で犯した最初の誤りは、明らかに、変数 x の項 t 内での自由な出現と、束 縛された出現を区別しなかったことである。</p>
</blockquote>

<p>つまり、置き換えの対象となる項の中に、変換規則の左辺と同じ名前の束縛変数があったら、そこで簡約を中止しなければならない。 この場合は以下の様な定義で表される。</p>

<blockquote>
<pre><code>[x |-&gt; s] x        = s
[x |-&gt; s] y        = y                (y != xの場合)
[x |-&gt; s] (λy. t1) = λy. t1           (y == xの場合)
[x |-&gt; s] (λy. t1) = λy. [x |-&gt; s] t1 (y != xの場合)
[x |-&gt; s] (t1 t2)  = ([x |-&gt; s] t1) ([x |-&gt; s] t2) 
</code></pre>
</blockquote>

<p>3行目がふえた。
しかし、これでも不完全である。</p>

<blockquote>
<pre><code>[x |-&gt; z] (λz. x) = λz. z
</code></pre>
</blockquote>

<p>今度は先ほどの例とは逆に、逆に束縛変数と競合してしまった。
そこで、制限を追加する。</p>

<blockquote>
<pre><code>[x |-&gt; s] x        = s
[x |-&gt; s] y        = y                (x != yの場合)
[x |-&gt; s] (λy. t1) = λy. t1           (x == yの場合)
[x |-&gt; s] (λy. t1) = λy. [x |-&gt; s] t1 (y != xかつFV(s)がyを含まない場合)
[x |-&gt; s] (t1 t2)  = ([x |-&gt; s] t1) ([x |-&gt; s] t2) 
</code></pre>
</blockquote>

<p>これで、少なくとも代入がおこなわれる時には、正しく動く。
しかし、制限を加えた結果、代入はもはや全域的な操作ではなくなった。
例えば、</p>

<pre><code>[x |-&gt; y z] (λy. x y) 
</code></pre>

<p>は、どのような結果も与えない。代入のどのルールも当てはまらないからである。
この問題に対する修正として、以下の様な慣習を取り入れる。</p>

<p>慣習 5.3.4. 束縛変数の名前のみが異なる項は、任意の文脈で置き換え可能である。</p>

<p>例えば、<code>[x |-&gt; y z] (λy. x y)</code>を計算したいときには、
最初に<code>(λy. x y)</code>を例えば<code>(λw. x w)</code>へと書き換える。
その後、<code>[x |-&gt; y z](λw. x w)</code> を計算し、<code>(λw. y z w)</code> を得る。</p>

<p>代入操作が未定義になるようなときには、常にこの慣習を適用することで、完全な代入の定義が得られる。</p>

<blockquote>
<pre><code>[x |-&gt; s] x        = s
[x |-&gt; s] y        = y                (x != yの場合)
[x |-&gt; s] (λy. t1) = λy. [x |-&gt; s] t1 (y != xかつFV(s)がyを含まない場合)
[x |-&gt; s] (t1 t2)  = ([x |-&gt; s] t1) ([x |-&gt; s] t2) 
</code></pre>
</blockquote>

<p><code>y==x</code>となる時や、 <code>FV(s)</code>がyを含むようなときには、抽象本体の束縛変数yを任意の変数名に置き換えればよい。
以上で、全域的な、破綻のない代入の形式的定義が得られた。</p>

<h3>
<a name="-3" class="anchor" href="#-3"><span class="octicon octicon-link"></span></a>操作的意味論</h3>

<p>まとめとして、操作的意味論の要約を示す。</p>

<p>構文:</p>

<blockquote>
<pre><code>t ::=                     項:
      x                 変数
      λx.t        ラムダ抽象
      t t           関数適用

v ::=                     値:
      λx.t        ラムダ抽象
</code></pre>
</blockquote>

<p>評価:</p>

<blockquote>
<pre><code>   t1 -&gt; t1'
---------------      (E-APP1)
t1 t2 -&gt; t1' t2

   t2 -&gt; t2'
---------------      (E-APP2)
v1 t2 -&gt; v1 t2'

(λx. t12) v2 -&gt; [x |-&gt; v2] t12  (E-APPABS)
</code></pre>
</blockquote>

<p>E-APPABSは計算規則であり、ラムダ計算唯一の簡約、関数適用を表す。
D-APP1とE-APP2は3章でもやったように、評価戦略を決定する合同規則である。</p>

<p>vは値、つまりラムダ抽象の上を動くことに注意すると、
これを規則に含むE-APP2とE-APPABSは、その項がラムダ抽象に簡約されるまで適用できない。
つまり、</p>

<ol>
<li>E-APP1によって関数適用の左側を評価する</li>
<li>E-APP2によって関数適用の右側を評価する</li>
<li>最後にE-APPABSによって関数適用という評価を行</li>
</ol><p>これは、値呼び評価戦略である。</p>

<blockquote>
<p>演習5.3.6. これらの規則を変更し、他の三種の評価戦略(完全ベータ簡約、正規順序、遅延評価)を表現するようにせよ。</p>
</blockquote>

<p>完全ベータ簡約は非決定である。
簡約順序に基底がなく、全ての簡約基はいかなるタイミングでも簡約可能だからである。</p>

<p>完全ベータ簡約の評価:</p>

<blockquote>
<pre><code>    t1 -&gt; t1'
 ---------------      (E-APP1)
 t1 t2 -&gt; t1' t2

    t2 -&gt; t2'
 ---------------      (E-APP2)
 v1 t2 -&gt; v1 t2'

    t1 -&gt; t1'
-----------------     (E-ABS)
λx. t1 -&gt; λx. t1'

(λx. t12) v2 -&gt; [x |-&gt; v2] t12  (E-APPABS)
</code></pre>
</blockquote>

<p>正規順序簡約の場合、外側の簡約基から評価しなければならない。
評価規則を正しく書き下すため、項を以下のように分類する。</p>

<blockquote>
<pre><code>nf ::=            正規形         
       λx. nf              
       nanf

nanf ::=          非抽象正規形           
         x
         nanf nf
na ::=            非抽象
       x
       t1 t2
</code></pre>
</blockquote>

<p>正規順序簡約は、完全ベータ簡約に評価の順序を与えたものである。</p>

<blockquote>
<pre><code>      na -&gt; t1'
   ---------------      (E-APP1)
   na t2 -&gt; t1' t2

      t2 -&gt; t2'
---------------------   (E-APP2)
nanf1 t2 -&gt; nanf1 t2'

      t1 -&gt; t1'
   ---------------      (E-ABS)
   λx. t1 -&gt; λx. t1'

   (λx. t12) v2 -&gt; [x |-&gt; v2] t12  (E-APPABS)
</code></pre>
</blockquote>

<p>遅延評価の規則は簡単である。抽象内部は評価されないので、規則E-APP2が削られている。</p>

<blockquote>
<pre><code>   t1 -&gt; t1'
---------------      (E-APP1)
t1 t2 -&gt; t1' t2

(λx. t12) v2 -&gt; [x |-&gt; v2] t12  (E-APPABS)
</code></pre>
</blockquote>
      </section>
    </div>

    
  </body>
</html>