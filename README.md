第X回 型システム入門勉強会
==========================

# 第5章 型無しラムダ計算 

## おさらい

Q1. ラムダ計算ってなんですか？

関数とその適用規則のみで表現された数理体系のことです。
文法は以下のとおり。

>     t ::=                     項:
>           x                 変数
>           λx.t        ラムダ抽象
>           t t           関数適用

たった4行の短い文法ですが、あらゆる計算を表現可能です。

Q2. どのへんが「形無し」なんですか？

そもそも本書における「型」について学んでないので「型無し」と言われても・・・という感じではありますが、
「項の定義において、右辺に再帰的に現れる項についていかなる制限も存在しないこと」
と捉えてよいと思います。

5.2「ラムダ計算でのプログラミング」ではChrch数の定義とその計算体系についてまとめられていました。

この体系は直感とは反する動きをする事があります。
たとえば、Chrchブール値は真偽値を表し、Chrch数は整数値を表していました。

>     tru = λt. λf. t;
>     c0 = λs. λz. z;

さらに、加算plusの定義は以下のとおり:

>     plus= λm. λn. λs. λz. m s (n s z);
    
この定義において、plus tru c0という項は、ラムダ計算上は評価可能です。

    plus tru c0 = ((λm. λn. λs. λz. m s (n s z)) tru) c0
                = (λn. λs. λz. tru s (n s z)) c0
                = λs. λz. tru s (c0 s z)
                = λs. λz. c0 s z
                = λs. λz. z

最終的にc0と等価なラムダ抽象へと簡約されていますが、これは明らかに直感に反しています。
そもそも真偽値と整数値を加算できること自体が、起きてはならない事象なのですから。
これはラムダ抽象に型が無いゆえに起きる問題です。

----

と書いたところで、p.43の値呼び戦略の評価の完了を見ていてふと疑問が・・・

>        id (id (λz. id z))
>      = id (λz. id z)
>      = λz. id z
>      // 簡約完了

なんでλz. id zはλz . zへと簡約されないのでしょうか？

 - zが閉じた項ではないから？
 - 抽象内部での簡約を許さないから？

これをふまえると、簡約基(tru s (c1 s z)をc0 s zへと監訳していいものか甚だ疑問ですが、
するとplus c0 c1のような妥当な項もc2へ簡約できません。

何が間違っているのでしょうか？

## 5.3 形式的議論

まずラムダ計算の構文を形式的に定義します。

> 定義 5.3.1.[項] V を変数名の可算集合とする。項の集合は以下を満たす最小の集合 T である。
> (1) 任意のx∈ V についてx∈ T
> (2) t1 ∈T かつx∈V ならば、λx.t1 ∈T
> (3) t1 ∈T かつt2 ∈T ならば、t1t2 ∈T

ここで、**項のサイズ**について考えます。
定義 3.3.2.と同様に定義できるらしい。

> 定義 3.3.2. 項 t のサイズを size(t) と書き、次のように定義する。

>     size(true)               = 1
>     size(false)              = 1
>     size(0)                  = 1
>     size(succ t1)            = size(t1) + 1
>     size(pred t1)            = size(t1) + 1
>     size(iszero t1)          = size(t1) + 1
>     size(ift1 thent2 elset3) = size(t1) + size(t2) + size(t3) + 1

つまり、tのサイズはtの抽象構文木のノードの数となります。

    size(x)      = 1
    size(λx. t1) = size(t1) + 1
    size(t1 t2)  = size(t1) + size(t2)

さらに、項に現れる自由変数の集合も再帰的に定義ができます。

> 定義5.3.2. 項tの自由変数(freevariable)の集合は、FV(t)と書かれ、以下のように定義できる。

>     FV(x)      = {x}
>     FV(λx. t1) = FV(t1) \ {x}
>     FV(t1 t2)  = FV(t1)∪FV(t2)

変数xという項の自由変数の集合は、xただ1つからなる集合である、という1つ目の定義が再帰的定義の基底です。
残りはラムダ計算の文法の再帰的定義に合わせて、

 - ラムダ抽象の引数は束縛変数（自由でない）ので抽象本体の自由変数の集合と{x}の差集合
 - 関数適用はt1とt2の2つの項の自由変数の集合の和集合

という感じ。

> 演習5.3.3. 任意の項tについて|FV(t)| ≤ size(t)が成り立つことを注意深く証明せよ。

tのサイズについて再帰的に証明します。
つまり、tより小さなサイズの項t1およびt2について、
```|FV(t1)| ≤ size(t1)```が成り立つと仮定し(t2も同様)、
tについても同様に成り立つことを示す。

ラムダ計算の定義の3つの右辺それぞれについて考える。

(1) t = xの場合
これは明らかに成り立つ。

    |FV(x)| = |{x}| = 1 = size(x)

(2) t = λx. t1の場合

    |FV(λx. t1)| = |FV(t1) \ {x}|

ここで、```|FV(t1)| ≤ size(t1)```という仮定より、```|FV(t1) \ {x}| ≤ size(t1)```である。
つまり、```|FV(t)| ≤ |FV(t1)|```は常に成り立つ。
仮定より```|FV(t)| ≤ |FV(t1)| ≤ size(t1) ≤ size(t)```が成り立つ。

(3) t = t1 t2の場合

    |FV(t1 t2)| = |FV(t1)∪FV(t2)|

であり、仮定より```|FV(t1)∪FV(t2)| ≤ size(t1) + size(t2)```となる。
定義より、```size(t1) + size(t2) = size(t1 t2)```であるから、
```|FV(t1 t2)| ≤ size(t1 t2)```が成り立つ。


