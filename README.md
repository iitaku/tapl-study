第X回 型システム入門勉強会
==========================

# 第5章 型無しラムダ計算 

## おさらい

Q1. ラムダ計算ってなんですか？

関数とその適用規則のみで表現された数理体系のことです。
文法は以下のとおり。

>     t ::=                     項:
>           x                 変数
>           λx.t        ラムダ抽象
>           t t           関数適用

たった4行の短い文法ですが、あらゆる計算を表現可能です。

Q2. どのへんが「形無し」なんですか？

そもそも本書における「型」について学んでないので「型無し」と言われても・・・という感じではありますが、
「項の定義において、右辺に再帰的に現れる項についていかなる制限も存在しないこと」
と捉えてよいと思います。

5.2「ラムダ計算でのプログラミング」ではChrch数の定義とその計算体系についてまとめられていました。

この体系は直感とは反する動きをする事があります。
たとえば、Chrchブール値は真偽値を表し、Chrch数は整数値を表していました。

>     tru = λt. λf. t;
>     c0 = λs. λz. z;

さらに、加算plusの定義は以下のとおり:

>     plus= λm. λn. λs. λz. m s (n s z);
    
この定義において、plus tru c0という項は、ラムダ計算上は評価可能です。

    plus tru c0 = ((λm. λn. λs. λz. m s (n s z)) tru) c0
                = (λn. λs. λz. tru s (n s z)) c0
                = λs. λz. tru s (c0 s z)
                = λs. λz. c0 s z
                = λs. λz. z

最終的にc0と等価なラムダ抽象へと簡約されていますが、これは明らかに直感に反しています。
そもそも真偽値と整数値を加算できること自体が、起きてはならない事象なのですから。
これはラムダ抽象に型が無いゆえに起きる問題です。

----

と書いたところで、p.43の値呼び戦略の評価の完了を見ていてふと疑問が・・・

>        id (id (λz. id z))
>      = id (λz. id z)
>      = λz. id z
>      // 簡約完了

なんでλz. id zはλz . zへと簡約されないのでしょうか？

 - zが閉じた項ではないから？
 - 抽象内部での簡約を許さないから？

これをふまえると、簡約基(tru s (c1 s z)をc0 s zへと監訳していいものか甚だ疑問ですが、
するとplus c0 c1のような妥当な項もc2へ簡約できません。

何が間違っているのでしょうか？

----

更に追記：

これは、いわゆる振る舞い等価では？

## 5.3 形式的議論

### 構文

まずラムダ計算の構文を形式的に定義します。

> 定義 5.3.1.[項] V を変数名の可算集合とする。項の集合は以下を満たす最小の集合 T である。
> (1) 任意のx∈ V についてx∈ T
> (2) t1 ∈T かつx∈V ならば、λx.t1 ∈T
> (3) t1 ∈T かつt2 ∈T ならば、t1t2 ∈T

ここで、**項のサイズ**について考えます。
定義 3.3.2.と同様に定義できるらしい。

> 定義 3.3.2. 項 t のサイズを size(t) と書き、次のように定義する。

>     size(true)               = 1
>     size(false)              = 1
>     size(0)                  = 1
>     size(succ t1)            = size(t1) + 1
>     size(pred t1)            = size(t1) + 1
>     size(iszero t1)          = size(t1) + 1
>     size(ift1 thent2 elset3) = size(t1) + size(t2) + size(t3) + 1

つまり、tのサイズはtの抽象構文木のノードの数となります。

    size(x)      = 1
    size(λx. t1) = size(t1) + 1
    size(t1 t2)  = size(t1) + size(t2)

さらに、項に現れる自由変数の集合も再帰的に定義ができます。

> 定義5.3.2. 項tの自由変数(freevariable)の集合は、FV(t)と書かれ、以下のように定義できる。

>     FV(x)      = {x}
>     FV(λx. t1) = FV(t1) \ {x}
>     FV(t1 t2)  = FV(t1)∪FV(t2)

変数xという項の自由変数の集合は、xただ1つからなる集合である、という1つ目の定義が再帰的定義の基底です。
残りはラムダ計算の文法の再帰的定義に合わせて、

 - ラムダ抽象の引数は束縛変数（自由でない）ので抽象本体の自由変数の集合と{x}の差集合
 - 関数適用はt1とt2の2つの項の自由変数の集合の和集合

という感じ。

> 演習5.3.3. 任意の項tについて|FV(t)| ≤ size(t)が成り立つことを注意深く証明せよ。

tのサイズについて再帰的に証明します。
つまり、tより小さなサイズの項t1およびt2について、
`|FV(t1)| ≤ size(t1)`が成り立つと仮定し(t2も同様)、
tについても同様に成り立つことを示す。

ラムダ計算の定義の3つの右辺それぞれについて考える。

(1) t = xの場合
これは明らかに成り立つ。

    |FV(x)| = |{x}| = 1 = size(x)

(2) t = λx. t1の場合

    |FV(λx. t1)| = |FV(t1) \ {x}|

ここで、`|FV(t1)| ≤ size(t1)`という仮定より、`|FV(t1) \ {x}| ≤ size(t1)`である。
つまり、`|FV(t)| ≤ |FV(t1)|`は常に成り立つ。
仮定より`|FV(t)| ≤ |FV(t1)| ≤ size(t1) ≤ size(t)`が成り立つ。

(3) t = t1 t2の場合

    |FV(t1 t2)| = |FV(t1)∪FV(t2)|

であり、仮定より`|FV(t1)∪FV(t2)| ≤ size(t1) + size(t2)`となる。
定義より、`size(t1) + size(t2) = size(t1 t2)`であるから、
`|FV(t1 t2)| ≤ size(t1 t2)`が成り立つ。

### 代入

代入の操作について、形式的に定義することを試みる。

まず最も素朴な定義から出発する。

>     [x |-> s] x        = s
>     [x |-> s] y        = y   (y != xの場合)
>     [x |-> s] (λy. t1) = λy. [x |-> s] t1
>     [x |-> s] (t1 t2)  = ([x |-> s] t1) ([x |-> s] t2) 

一見正しそうに見えるが、この代入はどうなるか？

    [x |-> y] (λx. x)

3つ目の定義より、抽象本体のxをyで置き換えて、こうなる。

    [x |-> y] (λx. x) = λx. y

これは、関数抽象において、束縛変数の名前を問わないという直感に反する。
たとえば次の代入の左辺は明らかに上の定義と等価だが、右辺は異なる。

    [x |-> y] (λz. z) = λz. z

ここでの問題は、自由変数と束縛変数を区別しなかったことにある。

> 代入のこの素朴な定義で犯した最初の誤りは、明らかに、変数 x の項 t 内での自由な出現と、束 縛された出現を区別しなかったことである。

つまり、置き換えの対象となる項の中に、変換規則の左辺と同じ名前の束縛変数があったら、そこで簡約を中止しなければならない。 この場合は以下の様な定義で表される。

>     [x |-> s] x        = s
>     [x |-> s] y        = y                (y != xの場合)
>     [x |-> s] (λy. t1) = λy. t1           (y == xの場合)
>     [x |-> s] (λy. t1) = λy. [x |-> s] t1 (y != xの場合)
>     [x |-> s] (t1 t2)  = ([x |-> s] t1) ([x |-> s] t2) 

3行目がふえた。
しかし、これでも不完全である。

>     [x |-> z] (λz. x) = λz. z

今度は先ほどの例とは逆に、逆に束縛変数と競合してしまった。
そこで、制限を追加する。

>     [x |-> s] x        = s
>     [x |-> s] y        = y                (x != yの場合)
>     [x |-> s] (λy. t1) = λy. t1           (x == yの場合)
>     [x |-> s] (λy. t1) = λy. [x |-> s] t1 (y != xかつFV(s)がyを含まない場合)
>     [x |-> s] (t1 t2)  = ([x |-> s] t1) ([x |-> s] t2) 

これで、少なくとも代入がおこなわれる時には、正しく動く。
しかし、制限を加えた結果、代入はもはや全域的な操作ではなくなった。
例えば、

    [x |-> y z] (λy. x y) 

は、どのような結果も与えない。代入のどのルールも当てはまらないからである。
この問題に対する修正として、以下の様な慣習を取り入れる。

慣習 5.3.4. 束縛変数の名前のみが異なる項は、任意の文脈で置き換え可能である。

例えば、`[x |-> y z] (λy. x y)`を計算したいときには、
最初に`(λy. x y)`を例えば`(λw. x w)`へと書き換える。
その後、`[x |-> y z](λw. x w)` を計算し、`(λw. y z w)` を得る。

代入操作が未定義になるようなときには、常にこの慣習を適用することで、完全な代入の定義が得られる。

>     [x |-> s] x        = s
>     [x |-> s] y        = y                (x != yの場合)
>     [x |-> s] (λy. t1) = λy. [x |-> s] t1 (y != xかつFV(s)がyを含まない場合)
>     [x |-> s] (t1 t2)  = ([x |-> s] t1) ([x |-> s] t2) 

`y==x`となる時や、 `FV(s)`がyを含むようなときには、抽象本体の束縛変数yを任意の変数名に置き換えればよい。
以上で、全域的な、破綻のない代入の形式的定義が得られた。

### 操作的意味論

まとめとして、操作的意味論の要約を示す。

構文:
>     t ::=                     項:
>           x                 変数
>           λx.t        ラムダ抽象
>           t t           関数適用
>
>     v ::=                     値:
>           λx.t        ラムダ抽象

評価:
>        t1 -> t1'
>     ---------------      (E-APP1)
>     t1 t2 -> t1' t2
>   
>        t2 -> t2'
>     ---------------      (E-APP2)
>     v1 t2 -> v1 t2'
>   
>     (λx. t12) v2 -> [x |-> v2] t12  (E-APPABS)
>   

E-APPABSは計算規則であり、ラムダ計算唯一の簡約、関数適用を表す。
D-APP1とE-APP2は3章でもやったように、評価戦略を決定する合同規則である。

vは値、つまりラムダ抽象の上を動くことに注意すると、
これを規則に含むE-APP2とE-APPABSは、その項がラムダ抽象に簡約されるまで適用できない。
つまり、

1. E-APP1によって関数適用の左側を評価する
2. E-APP2によって関数適用の右側を評価する
3. 最後にE-APPABSによって関数適用という評価を行

これは、値呼び評価戦略である。

> 演習5.3.6. これらの規則を変更し、他の三種の評価戦略(完全ベータ簡約、正規順序、遅延評価)を表現するようにせよ。

完全ベータ簡約は非決定である。
簡約順序に基底がなく、全ての簡約基はいかなるタイミングでも簡約可能だからである。

完全ベータ簡約の評価:
>         t1 -> t1'
>      ---------------      (E-APP1)
>      t1 t2 -> t1' t2
>   
>         t2 -> t2'
>      ---------------      (E-APP2)
>      v1 t2 -> v1 t2'
>
>         t1 -> t1'
>     -----------------     (E-ABS)
>     λx. t1 -> λx. t1'
>   
>     (λx. t12) v2 -> [x |-> v2] t12  (E-APPABS)
>   

正規順序簡約の場合、外側の簡約基から評価しなければならない。
評価規則を正しく書き下すため、項を以下のように分類する。


>     nf ::=            正規形         
>            λx. nf              
>            nanf
>
>     nanf ::=          非抽象正規形           
>              x
>              nanf nf
>     na ::=            非抽象
>            x
>            t1 t2


正規順序簡約は、完全ベータ簡約に評価の順序を与えたものである。

>           na -> t1'
>        ---------------      (E-APP1)
>        na t2 -> t1' t2
>   
>           t2 -> t2'
>     ---------------------   (E-APP2)
>     nanf1 t2 -> nanf1 t2'
>
>           t1 -> t1'
>        ---------------      (E-ABS)
>        λx. t1 -> λx. t1'
>
>        (λx. t12) v2 -> [x |-> v2] t12  (E-APPABS)
>   

遅延評価の規則は簡単である。抽象内部は評価されないので、規則E-APP2が削られている。

>        t1 -> t1'
>     ---------------      (E-APP1)
>     t1 t2 -> t1' t2
>   
>     (λx. t12) v2 -> [x |-> v2] t12  (E-APPABS)

